<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Telegram Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            /* –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–∫—Ä–æ–ª–ª –∏ –∑—É–º, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–ª–∏–∫–∞—Ç—å */
            overscroll-behavior: none;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        /* –†–∞–∑—Ä–µ—à–∞–µ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –∏–Ω–ø—É—Ç–∞–º–∏ –∏ –∫–Ω–æ–ø–∫–∞–º–∏ */
        input, button {
            touch-action: manipulation;
            user-select: text;
        }
        canvas {
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        .glass-input {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .glass-input:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
        }
        .input-error {
            border-color: #ef4444 !important;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5) !important;
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center h-screen w-full overflow-hidden font-mono">

    <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
    <div class="w-full max-w-md px-4 flex justify-between items-center mb-4 pointer-events-none">
        <div class="text-xl font-bold text-green-400 flex items-center gap-2">
            <span>üêç</span> <span id="score">0</span>
        </div>
        <div class="text-sm text-gray-400">
            –†–µ–∫–æ—Ä–¥: <span id="high-score">0</span>
        </div>
    </div>

    <!-- –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä -->
    <div class="relative">
        <canvas id="gameCanvas" class="bg-gray-800 rounded-lg border-2 border-gray-700 block"></canvas>
        
        <!-- –û–≤–µ—Ä–ª–µ–π (–ú–µ–Ω—é) -->
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-black/90 rounded-lg z-50 p-6 transition-opacity duration-300">
            <h1 class="text-4xl font-bold text-green-500 mb-2 tracking-widest">SNAKE</h1>
            <p id="status-text" class="text-gray-300 mb-4 text-center text-sm">–í–≤–µ–¥–∏—Ç–µ –∏–º—è:</p>
            
            <!-- –ò–Ω–ø—É—Ç -->
            <div class="mb-6 w-full max-w-[200px]">
                <input type="text" id="player-name" placeholder="–ò–º—è" maxlength="12" 
                       class="glass-input w-full px-4 py-3 rounded-lg text-center text-white placeholder-gray-500 transition-all text-lg">
            </div>

            <!-- –ö–Ω–æ–ø–∫–∞ -->
            <button id="start-btn" class="bg-green-600 active:bg-green-700 hover:bg-green-500 text-white font-bold py-4 px-8 rounded-full shadow-lg transition transform active:scale-95 w-full max-w-[200px]">
                –ò–ì–†–ê–¢–¨
            </button>
        </div>
    </div>

    <div class="mt-6 text-gray-500 text-xs text-center max-w-xs pointer-events-none">
        <p class="mb-1">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –°–≤–∞–π–ø—ã –∏–ª–∏ –°—Ç—Ä–µ–ª–∫–∏</p>
    </div>

    <script>
        // --- Telegram Setup ---
        const tg = window.Telegram.WebApp;
        tg.expand(); 
        tg.ready();

        // –ê–≤—Ç–æ-–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–º–µ–Ω–∏
        const nameInput = document.getElementById('player-name');
        if (tg.initDataUnsafe?.user?.first_name) {
            nameInput.value = tg.initDataUnsafe.user.first_name;
        }

        // –¶–≤–µ—Ç–∞ —Ç–µ–º—ã
        if (tg.themeParams) {
            document.body.style.backgroundColor = tg.themeParams.bg_color || '#111827';
            document.body.style.color = tg.themeParams.text_color || '#ffffff';
        }

        // --- Game Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        const statusText = document.getElementById('status-text');

        // --- Settings ---
        const GRID_SIZE = 20;
        let TILE_SIZE = 0;
        let gameInterval;
        let gameRunning = false;
        
        // --- State ---
        let snake = [];
        let food = {};
        let direction = 'RIGHT';
        let nextDirection = 'RIGHT';
        let score = 0;
        let highScore = localStorage.getItem('snake_highscore') || 0;
        highScoreEl.innerText = highScore;
        let speed = 120;

        // --- Resizing ---
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 32, 400);
            const maxHeight = window.innerHeight - 150;
            const size = Math.min(maxWidth, maxHeight);
            
            TILE_SIZE = Math.floor(size / GRID_SIZE);
            canvas.width = TILE_SIZE * GRID_SIZE;
            canvas.height = TILE_SIZE * GRID_SIZE;
            
            if (!gameRunning) draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Game Logic ---

        function startGameHandler(e) {
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–≤–æ–π–Ω–æ–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ (click + touch)
            if (e && e.cancelable) e.preventDefault();
            
            const playerName = nameInput.value.trim();
            
            // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏
            if (!playerName) {
                nameInput.classList.add('input-error');
                if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('error');
                setTimeout(() => nameInput.classList.remove('input-error'), 500);
                nameInput.focus();
                return;
            }

            // –°–±—Ä–æ—Å UI
            nameInput.blur(); // –°–∫—Ä—ã–≤–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
            overlay.style.opacity = '0';
            setTimeout(() => overlay.classList.add('hidden'), 300);

            // –°—Ç–∞—Ä—Ç –ª–æ–≥–∏–∫–∏
            initGameLogic();
        }

        function initGameLogic() {
            snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
            direction = 'RIGHT';
            nextDirection = 'RIGHT';
            score = 0;
            speed = 120;
            scoreEl.innerText = score;
            spawnFood();
            gameRunning = true;

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, speed);
        }

        function spawnFood() {
            while (true) {
                let newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
                let onSnake = snake.some(s => s.x === newFood.x && s.y === newFood.y);
                if (!onSnake) {
                    food = newFood;
                    break;
                }
            }
        }

        function gameLoop() {
            direction = nextDirection;
            let headX = snake[0].x;
            let headY = snake[0].y;

            if (direction === 'LEFT') headX--;
            if (direction === 'UP') headY--;
            if (direction === 'RIGHT') headX++;
            if (direction === 'DOWN') headY++;

            if (headX < 0 || headX >= GRID_SIZE || headY < 0 || headY >= GRID_SIZE || checkCollision(headX, headY)) {
                gameOver();
                return;
            }

            const newHead = { x: headX, y: headY };

            if (headX === food.x && headY === food.y) {
                score++;
                scoreEl.innerText = score;
                if (tg.HapticFeedback) tg.HapticFeedback.impactOccurred('medium');
                
                if (score % 5 === 0 && speed > 60) {
                    clearInterval(gameInterval);
                    speed -= 5;
                    gameInterval = setInterval(gameLoop, speed);
                }
                snake.unshift(newHead);
                spawnFood();
            } else {
                snake.pop();
                snake.unshift(newHead);
            }
            draw();
        }

        function checkCollision(x, y) {
            return snake.some(s => s.x === x && s.y === y);
        }

        function draw() {
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Food
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            const fX = food.x * TILE_SIZE + TILE_SIZE / 2;
            const fY = food.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.arc(fX, fY, TILE_SIZE / 2 - 2, 0, Math.PI * 2);
            ctx.fill();

            // Snake
            snake.forEach((s, i) => {
                ctx.fillStyle = i === 0 ? '#22c55e' : '#4ade80';
                ctx.fillRect(s.x * TILE_SIZE + 1, s.y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            });
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameInterval);
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('error');

            const playerName = nameInput.value.trim();
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∫–æ—Ä–¥ –ª–æ–∫–∞–ª—å–Ω–æ
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snake_highscore', highScore);
                highScoreEl.innerText = highScore;
                statusText.innerText = `–ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥: ${score}!`;
            } else {
                statusText.innerText = `–°—á–µ—Ç: ${score}`;
            }

            startBtn.innerText = "–ï–©–ï –†–ê–ó";
            overlay.classList.remove('hidden');
            overlay.style.opacity = '1';

            // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            const data = JSON.stringify({ action: 'save_score', name: playerName, score: score });
            tg.sendData(data);
        }

        // --- Input Listeners ---
        // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ –∫–ª–∏–∫–∞, –∏ —Ç–∞—á–∞ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
        startBtn.addEventListener('click', startGameHandler);
        startBtn.addEventListener('touchstart', startGameHandler, { passive: false });

        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            const k = e.key;
            if ((k === 'ArrowLeft' || k === 'a') && direction !== 'RIGHT') nextDirection = 'LEFT';
            if ((k === 'ArrowUp' || k === 'w') && direction !== 'DOWN') nextDirection = 'UP';
            if ((k === 'ArrowRight' || k === 'd') && direction !== 'LEFT') nextDirection = 'RIGHT';
            if ((k === 'ArrowDown' || k === 's') && direction !== 'UP') nextDirection = 'DOWN';
        });

        // Swipe Controls
        let tsX = 0, tsY = 0;
        document.addEventListener('touchstart', e => { tsX = e.changedTouches[0].screenX; tsY = e.changedTouches[0].screenY; }, {passive: false});
        document.addEventListener('touchmove', e => { if(gameRunning) e.preventDefault(); }, {passive: false}); // –ë–ª–æ–∫–∏—Ä—É–µ—Ç —Å–∫—Ä–æ–ª–ª —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã
        document.addEventListener('touchend', e => {
            if (!gameRunning) return;
            const teX = e.changedTouches[0].screenX;
            const teY = e.changedTouches[0].screenY;
            const dx = teX - tsX;
            const dy = teY - tsY;
            
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–∞–ø

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && direction !== 'LEFT') nextDirection = 'RIGHT';
                else if (dx < 0 && direction !== 'RIGHT') nextDirection = 'LEFT';
            } else {
                if (dy > 0 && direction !== 'UP') nextDirection = 'DOWN';
                else if (dy < 0 && direction !== 'DOWN') nextDirection = 'UP';
            }
        }, {passive: false});

        // Init
        draw();
    </script>
</body>
</html>
