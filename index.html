import asyncio
import logging
import json
import sqlite3
import sys
from datetime import datetime
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import CommandStart
from aiogram.types import MenuButtonWebApp, WebAppInfo
from aiogram.client.session.aiohttp import AiohttpSession 
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# ==========================================
# –ù–ê–°–¢–†–û–ô–ö–ò
# ==========================================
TOKEN = "8211548854:AAHMWWYlYB7-biakPhOvjPdwP8m8H6BRotU" 
SNAKE_URL = "https://inbbbb-cmd.github.io/rep1/" 
BOMBERMAN_URL = "https://inbbbb-cmd.github.io/bomberman1/"
MINESWEEPER_URL = "https://inbbbb-cmd.github.io/minesweeper1/"
ESCAPE_URL = "https://inbbbb-cmd.github.io/escape/"            # –ù–æ–≤–∞—è –∏–≥—Ä–∞ 1
SPACEDEFENDER_URL = "https://inbbbb-cmd.github.io/spacedefender/" # –ù–æ–≤–∞—è –∏–≥—Ä–∞ 2
ADMIN_ID = 6714155003
# ==========================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

# --- –ë–ê–ó–ê –î–ê–ù–ù–´–• ---
def init_db():
    try:
        conn = sqlite3.connect('snake.db')
        cur = conn.cursor()
        # –¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∫–æ—Ä–¥–æ–≤
        cur.execute('''
            CREATE TABLE IF NOT EXISTS scores (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                score INTEGER,
                updated_at TEXT
            )
        ''')
        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        cur.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                joined_at TEXT
            )
        ''')
        conn.commit()
        conn.close()
        logging.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ë–î: {e}")

def save_score(user_id, username, score):
    conn = sqlite3.connect('snake.db')
    cur = conn.cursor()
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ä–µ–∫–æ—Ä–¥
    cur.execute('SELECT score FROM scores WHERE user_id = ?', (user_id,))
    row = cur.fetchone()
    current_best = row[0] if row else 0
    
    is_new_record = False
    # –ï—Å–ª–∏ –Ω–æ–≤—ã–π —Å—á–µ—Ç –±–æ–ª—å—à–µ —Å—Ç–∞—Ä–æ–≥–æ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º
    if score > current_best:
        cur.execute('''
            INSERT INTO scores (user_id, username, score, updated_at)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                username = excluded.username,
                score = excluded.score,
                updated_at = excluded.updated_at
        ''', (user_id, username, score, datetime.now().isoformat()))
        is_new_record = True
        
    conn.commit()
    conn.close()
    return is_new_record, current_best

def get_top_players(limit=5):
    conn = sqlite3.connect('snake.db')
    cur = conn.cursor()
    cur.execute('SELECT username, score FROM scores ORDER BY score DESC LIMIT ?', (limit,))
    results = cur.fetchall()
    conn.close()
    return results

def get_all_users():
    conn = sqlite3.connect('snake.db')
    cur = conn.cursor()
    cur.execute('SELECT user_id FROM users')
    users = [row[0] for row in cur.fetchall()]
    conn.close()
    return users

# --- –ë–û–¢ –° –ü–†–û–ö–°–ò (–î–õ–Ø PYTHONANYWHERE) ---
# –ï—Å–ª–∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ –ª–æ–∫–∞–ª—å–Ω–æ (–Ω–µ –Ω–∞ PythonAnywhere), –≤–æ–∑–º–æ–∂–Ω–æ, proxy –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å: session=None
session = AiohttpSession(proxy="http://proxy.server:3128")
bot = Bot(token=TOKEN, session=session)
dp = Dispatcher()

@dp.message(CommandStart())
async def start(message: types.Message):
    user_id = message.from_user.id
    conn = sqlite3.connect('snake.db')
    cur = conn.cursor()
    cur.execute('INSERT OR IGNORE INTO users (user_id, joined_at) VALUES (?, ?)', 
                (user_id, datetime.now().isoformat()))
    conn.commit()
    conn.close()

    # –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é (—Å–ª–µ–≤–∞ –æ—Ç –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞) –æ—Å—Ç–∞–≤–∏–º –Ω–∞ –ó–º–µ–π–∫—É –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω—É—é –∏–≥—Ä—É
    await bot.set_chat_menu_button(
        chat_id=message.chat.id,
        menu_button=MenuButtonWebApp(text="–ò–≥—Ä–∞—Ç—å", web_app=WebAppInfo(url=SNAKE_URL))
    )
    
    # –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –ü–Ø–¢–¨–Æ –∫–Ω–æ–ø–∫–∞–º–∏
    kb = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üêç –ó–º–µ–π–∫–∞", web_app=WebAppInfo(url=SNAKE_URL))],
        [types.InlineKeyboardButton(text="üí£ –ë–æ–º–±–µ—Ä–º–µ–Ω", web_app=WebAppInfo(url=BOMBERMAN_URL))],
        [types.InlineKeyboardButton(text="üö© –°–∞–ø–µ—Ä", web_app=WebAppInfo(url=MINESWEEPER_URL))],
        [types.InlineKeyboardButton(text="üèÉ –ü–æ–±–µ–≥", web_app=WebAppInfo(url=ESCAPE_URL))],
        [types.InlineKeyboardButton(text="üöÄ –ó–∞—â–∏—Ç–Ω–∏–∫ –∫–æ—Å–º–æ—Å–∞", web_app=WebAppInfo(url=SPACEDEFENDER_URL))]
    ])
    
    await message.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! \n–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:", 
        reply_markup=kb
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ—Ç –∏–≥—Ä
@dp.message(F.web_app_data)
async def handle_data(message: types.Message):
    try:
        data = json.loads(message.web_app_data.data)
        
        # –ï—Å–ª–∏ –∏–≥—Ä–∞ –ø—Ä–∏—Å–ª–∞–ª–∞ –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—á–∫–æ–≤
        if data.get('action') == 'save_score':
            score = int(data['score'])
            name = data['name']
            user_id = message.from_user.id
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –æ–±—â—É—é –±–∞–∑—É
            # –í–ù–ò–ú–ê–ù–ò–ï: –°–µ–π—á–∞—Å –±–∞–∑–∞ —Ö—Ä–∞–Ω–∏—Ç –æ–¥–∏–Ω –æ–±—â–∏–π —Ä–µ–∫–æ—Ä–¥ –¥–ª—è –∏–≥—Ä–æ–∫–∞.
            # –ï—Å–ª–∏ –≤ —Ä–∞–∑–Ω—ã—Ö –∏–≥—Ä–∞—Ö —Å—á–µ—Ç —Å–∏–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è (10 –æ—á–∫–æ–≤ –ø—Ä–æ—Ç–∏–≤ 10000),
            # –≤–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç —Å–æ–∑–¥–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –∏–ª–∏ —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –∫–∞–∂–¥–æ–π –∏–≥—Ä—ã.
            is_new_record, old_score = save_score(user_id, name, score)
            
            if is_new_record:
                await message.answer(f"üöÄ <b>–ù–û–í–´–ô –†–ï–ö–û–†–î!</b>\n–ò–≥—Ä–æ–∫: {name}\n–°—á–µ—Ç: {score}")
            else:
                await message.answer(f"–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞. –¢–≤–æ–π —Å—á–µ—Ç: {score}. \n–õ—É—á—à–∏–π —Ä–µ–∫–æ—Ä–¥: {old_score}")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö WebApp: {e}")

# --- –†–ê–°–°–´–õ–ö–ê ---
async def daily_top():
    logging.info("–ù–∞—á–∏–Ω–∞–µ–º –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Ä–∞—Å—Å—ã–ª–∫—É...")
    top = get_top_players(10)
    if not top:
        return

    text = "üèÜ <b>–¢–û–ü –ò–ì–†–û–ö–û–í</b> üèÜ\n\n"
    for i, (name, score) in enumerate(top, 1):
        medal = "ü•á" if i==1 else "ü•à" if i==2 else "ü•â" if i==3 else "üî∏"
        text += f"{medal} {i}. <b>{name}</b> ‚Äî {score}\n"
    
    text += "\n–ö—Ç–æ —Å–º–æ–∂–µ—Ç –∏—Ö –æ–±–æ–≥–Ω–∞—Ç—å? üëá"
    
    users = get_all_users()
    count = 0
    for user_id in users:
        try:
            await bot.send_message(user_id, text)
            count += 1
            await asyncio.sleep(0.1)
        except Exception:
            pass
            
    logging.info(f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.")

async def main():
    init_db()
    
    scheduler = AsyncIOScheduler()
    scheduler.add_job(daily_top, 'cron', hour=12, minute=0)
    scheduler.start()
    
    await bot.delete_webhook(drop_pending_updates=True)
    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
    await dp.start_polling(bot)

if __name__ == '__main__':
    if TOKEN == "–í–°–¢–ê–í–¨_–°–Æ–î–ê_–¢–û–ö–ï–ù":
        print("–û–®–ò–ë–ö–ê: –¢–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
    else:
        asyncio.run(main())
